# 브라우저의 렌더링 과정

## 38.1) 요청과 응답
- 브라우저의 주소창에 리소스를 요청하는 내용을 포함한 URL을 입력하고 엔터 키를 누르면 URL의 호스트 이름이 DNS를 통해 IP 주소로 변환됨
- 서버는 요청받은 리소스에 대한 응답을 브라우저에게 보냄
- 브라우저는 응답받은 리소스를 파싱하는 과정에서 CSS, JS, 이미지 파일을 로드하는 태그들을 만나면 해당 리소스 파일도 서버에 요청

## 38.2) HTTP 1.1과 HTTP 2.0
- HTTP(HyperText Transfer Protocol)는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜
- HTTP 1.1 : 기본적으로 커넥션당 하나의 요청과 응답만 처리
- HTTP 2.0 : 커넥션당 여러 개의 요청청과 응답이 가능

## 38.3) HTML 파싱과 DOM 생성
- 브라우저의 렌더링 엔진은 다음 그림과 같은 과정을 통해 응답은 HTML 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM(Document Object Model)을 생성
- DOM은 HTML 문서를 파싱한 결과물

## 38.4) CSS 파싱과 CSSOM 생성
- 렌더링 엔진은 HTML을 한 줄씩 순차적으로 파싱하여 DOM을 생성
- CSS를 로드하는 link 태그를 만나면, DOM 생성을 일시 중지하고, CSS를 HTML과 동일한 파싱 과정을 거치며 CSSSOM(CSS Object Model)을 생성
- CSS 파싱을 완료하면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재게

## 38.5) 렌더 트리 생성
- 렌더링 엔진은 DOM과 CSSOM을 렌더 트리로 결합
- 렌더 트리는 렌더링을 위한 트리 구조의 자료구조
- 브라우저 화면에 렌더링되지 않는 노드들과 CSS에 의해 비표시 되는 노드들은 포함하지 않음

## 38.6) 자바스크립트 파싱과 실행
- 자바스크립트 파일을 로드하는 script 태그를 만나면, DOM 생성을 일시 중지하고, 제어권이 브라우저의 엔진에서 자바스크립트 엔진으로 넘어감
- 자바스크립트 엔진은 AST(Abstract Syntax Tree)를 생성
- 자바스크립트 파싱과 실행이 종료되면 제어권이 브라우저 엔진으로 다시 넘겨 받음

## 38.7) 리플로우와 리페인트
- 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM이나 CSSOM이 변경됨
- 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 레더 트리를 기반으로 다시 랜더링함
- 리플로우 : 레이아웃 계산을 다시 하는 것
- 리페인트 : 재결합된 렌더 트리를 기반으로 다시 페인트 하는 것

## 38.8) 자바스크립트 파싱에 의한 HTML 파싱 중단
### body 요소의 가장 아래에 자바스크립트를 위치 시키는것이 좋은 이유
- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있음
- 페이지 로딩 시간이 단축 됨

## 38.9) script 태그의 async/defer 어트리뷰트
- async와 defer는 자바스크립트의 파일의 로드가 비동기적으로 동시에 진행됨
- async와 defer는 src 어트리뷰트를 통해 외부 자바스크립트 파일을 로드하는 경우에만 사용 가능
### async
- 자바스크립트 파일 로드가 완료된 직후에 HTML 파싱이 중단되고 자바스크립트의 실행이 진행됨
- script 태그의 순서와는 상관없이 로드가 완료된 자바스크립트부터 먼저 실행되므로 순서가 보장되지 않음
- DOM을 조작하지 않는 코드에만 사용해야 함
### defer
- 파싱이 완료된 직후에 자바스크립트의 실행이 진행됨